Projet Réseau
Morpion aveugle

Julien COUVY
Gauthier LAMARQUE

1.Présentation du projet

Structure:

Afin de réaliser un jeu de morpion aveugle, nous avons décidé de le stucturer avec des classes.
Ces classes sont les suivantes:
la classe User,
la classe Game,
la classe Room.

La classe User représente un client (dans le modèle serveur/client). Cette classe contient les attributs suivants:
la socket associée au client,
un nom qui peut être modifié par le client ("Guest[0...9999] par défaut),
et l'IP du client que l'on obtient lors de la connexion.

La classe Game représente un salon de jeu, où l'on peut faire une partie de morpion ou observer une partie en cours.
Elle contient les attributs suivants:
l'identifiant du salon de jeu,
une paire de joueurs,
une liste d'observateurs,
trois grilles aux contenus différents:
	la première contient les coups joués par le Joueur 1,
	la deuxième les coups joués par le Joueur 2,
	et enfin la dernière contient tous les coups joués et est envoyée aux observateurs présents.
un entier indiquant le tour de jeu.

La classe Room est un salon d'accueil où les clients sont envoyés à la connexion. Depuis ce salon d'accueil, les clients peuvent rejoindre un salon de jeu, ou effectuer diverses actions, comme changer de pseudonyme, obtenir une liste des salons de jeu ou des utilisateurs présents dans le salon d'accueil.
Elle contient les attributs suivants:
une liste de clients,
une liste de salons de jeu (3 dans notre implémentation, choix arbitraire).

Pourquoi cette structure?

Nous avons choisi cette structure car nous avions en tête de réaliser des parties multiples observables, et nous pensions que cette structure pouvait remplir ces objectifs. Ce niveau d'abstraction nous permet aussi d'avoir un code très peu redondant, et plutôt modulaire.
L'utilisation de classes permet de différencier aisément les diverses entités que l'on manipule, et de faciliter l'imbrication de ces entités (par exemple : ajouter un joueur dans un salon de jeu attenant au salon d'accueil).

Protocole de communication:

Pour que les clients et le serveur puissent communiquer, nous avons établi un protocole permettant à chacun de recevoir et traiter des commandes. Conforme au sujet, le client doit réaliser les affichages. Le protocole est de la forme suivante:
"PREFIXE <contenu>$"
Le préfixe de la commande est une petite chaîne de caractères majuscules qui permet au client de savoir quel est le type de la commande reçue (par exemple "GRID <contenu>$" indique au client qu'il doit remplir sa grille et l'afficher)
Le contenu lui dépend du type de la commande, il peut être inexistant sur certaines commandes.
Le caractère '$' nous sert de délimiteur. En effet, à cause du protocole TCP, le client peut recevoir des commandes concaténées. Afin de séparer ces commandes, nous avons choisi d'utiliser un délimiteur permettant de séparer ces commandes et les exécuter dans l'ordre.

Fonctionnalités:

Comme précisé dans le sujet, le serveur et le client utilisent le même fichier pour s'exécuter. Seul le nombre d'argument change. En effet le client doit renseigner une adresse à laquelle se connecter alors que le serveur n'a pas besoin d'ajouter d'arguments.
La connexion est de type TCP (comme celle que l'on a vue lors du TP "Serveur de chat"). Nous avons séparé les codes des clients et du serveur dans des fichiers distincts.
A la connexion, le client se retrouve dans le salon d'accueil (Room dans le code), et on lui donne la liste des commandes possibles, c'est à dire, changer de pseudonyme, obtenir la liste des autres clients ou des parties ou enfin rejoindre une partie. Les entrées client sont gérées par un processus léger (thread) car la fonction "inpu.t()" est bloquante, c'est à dire que tant qu'il n'y a pas d'entrée client, on ne peut rien afficher. L'utilisation du processus léger permet d'afficher au client les divers messages du serveur tout en assurant une possible entrée clavier.
